/**
 * @internal
 */
var RefFlag = "__v_isRef";
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref$1(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  var ref = {};
  def(ref, RefFlag, true);
  def(ref, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, shallow);
  def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));
  return ref;
}
function triggerRef(ref) {
  if (!ref.dep) {
    warn$2("received object is not a triggerable ref.");
  }
  {
    ref.dep &&
      ref.dep.notify({
        type: "set" /* TriggerOpTypes.SET */,
        target: ref,
        key: 'value'
      });
  }
}
function unref(ref) {
  return isRef(ref) ? ref.value : ref;
}
function proxyRefs(objectWithRefs) {
  if (isReactive(objectWithRefs)) {
    return objectWithRefs;
  }
  var proxy = {};
  var keys = Object.keys(objectWithRefs);
  for (var i = 0; i < keys.length; i++) {
    proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);
  }
  return proxy;
}
function proxyWithRefUnwrap(target, source, key) {
  Object.defineProperty(target, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      var val = source[key];
      if (isRef(val)) {
        return val.value;
      }
      else {
        var ob = val && val.__ob__;
        if (ob)
          ob.dep.depend();
        return val;
      }
    },
    set: function (value) {
      var oldValue = source[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
      }
      else {
        source[key] = value;
      }
    }
  });
}
function customRef(factory) {
  var dep = new Dep();
  var _a = factory(function () {
    {
      dep.depend({
        target: ref,
        type: "get" /* TrackOpTypes.GET */,
        key: 'value'
      });
    }
  }, function () {
    {
      dep.notify({
        target: ref,
        type: "set" /* TriggerOpTypes.SET */,
        key: 'value'
      });
    }
  }), get = _a.get, set = _a.set;
  var ref = {
    get value() {
      return get();
    },
    set value(newVal) {
      set(newVal);
    }
  };
  def(ref, RefFlag, true);
  return ref;
}
function toRefs(object) {
  if (!isReactive(object)) {
    warn$2("toRefs() expects a reactive object but received a plain one.");
  }
  var ret = isArray(object) ? new Array(object.length) : {};
  for (var key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
function toRef(object, key, defaultValue) {
  var val = object[key];
  if (isRef(val)) {
    return val;
  }
  var ref = {
    get value() {
      var val = object[key];
      return val === undefined ? defaultValue : val;
    },
    set value(newVal) {
      object[key] = newVal;
    }
  };
  def(ref, RefFlag, true);
  return ref;
}

var rawToReadonlyFlag = "__v_rawToReadonly";
var rawToShallowReadonlyFlag = "__v_rawToShallowReadonly";
function readonly(target) {
  return createReadonly(target, false);
}
function createReadonly(target, shallow) {
  if (!isPlainObject(target)) {
    {
      if (isArray(target)) {
        warn$2("Vue 2 does not support readonly arrays.");
      }
      else if (isCollectionType(target)) {
        warn$2("Vue 2 does not support readonly collection types such as Map or Set.");
      }
      else {
        warn$2("value cannot be made readonly: ".concat(typeof target));
      }
    }
    return target;
  }
  if (!Object.isExtensible(target)) {
    warn$2("Vue 2 does not support creating readonly proxy for non-extensible object.");
  }
  // already a readonly object
  if (isReadonly(target)) {
    return target;
  }
  // already has a readonly proxy
  var existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;
  var existingProxy = target[existingFlag];
  if (existingProxy) {
    return existingProxy;
  }
  var proxy = Object.create(Object.getPrototypeOf(target));
  def(target, existingFlag, proxy);
  def(proxy, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, true);
  def(proxy, "__v_raw" /* ReactiveFlags.RAW */, target);
  if (isRef(target)) {
    def(proxy, RefFlag, true);
  }
  if (shallow || isShallow(target)) {
    def(proxy, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
  }
  var keys = Object.keys(target);
  for (var i = 0; i < keys.length; i++) {
    defineReadonlyProperty(proxy, target, keys[i], shallow);
  }
  return proxy;
}
function defineReadonlyProperty(proxy, target, key, shallow) {
  Object.defineProperty(proxy, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      var val = target[key];
      return shallow || !isPlainObject(val) ? val : readonly(val);
    },
    set: function () {
      warn$2("Set operation on key \"".concat(key, "\" failed: target is readonly."));
    }
  });
}
/**
* Returns a reactive-copy of the original object, where only the root level
* properties are readonly, and does NOT unwrap refs nor recursively convert
* returned properties.
* This is used for creating the props proxy object for stateful components.
*/
function shallowReadonly(target) {
  return createReadonly(target, true);
}

function computed(getterOrOptions, debugOptions) {
  var getter;
  var setter;
  var onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = function () {
      warn$2('Write operation failed: computed value is readonly');
    }
      ;
  }
  else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  var watcher = isServerRendering()
    ? null
    : new Watcher(currentInstance, getter, noop, { lazy: true });
  if (watcher && debugOptions) {
    watcher.onTrack = debugOptions.onTrack;
    watcher.onTrigger = debugOptions.onTrigger;
  }
  var ref = {
    // some libs rely on the presence effect for checking computed refs
    // from normal refs, but the implementation doesn't matter
    effect: watcher,
    get value() {
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          if (Dep.target.onTrack) {
            Dep.target.onTrack({
              effect: Dep.target,
              target: ref,
              type: "get" /* TrackOpTypes.GET */,
              key: 'value'
            });
          }
          watcher.depend();
        }
        return watcher.value;
      }
      else {
        return getter();
      }
    },
    set value(newVal) {
      setter(newVal);
    }
  };
  def(ref, RefFlag, true);
  def(ref, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, onlyGetter);
  return ref;
}

var mark;
var measure;
{
  var perf_1 = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf_1 &&
    // @ts-ignore
    perf_1.mark &&
    // @ts-ignore
    perf_1.measure &&
    // @ts-ignore
    perf_1.clearMarks &&
    // @ts-ignore
    perf_1.clearMeasures) {
    mark = function (tag) { return perf_1.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf_1.measure(name, startTag, endTag);
      perf_1.clearMarks(startTag);
      perf_1.clearMarks(endTag);
      // perf.clearMeasures(name)
    };
  }
}

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once,
    capture: capture,
    passive: passive
  };
});
function createFnInvoker(fns, vm) {
  function invoker() {
    var fns = invoker.fns;
    if (isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments, vm, "v-on handler");
      }
    }
    else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }
  invoker.fns = fns;
  return invoker;
}
function updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      warn$2("Invalid handler for event \"".concat(event.name, "\": got ") + String(cur), vm);
    }
    else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    }
    else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove(event.name, oldOn[name], event.capture);
    }
  }
}

function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];
  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove$2(invoker.fns, wrappedHook);
  }
  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  }
  else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    }
    else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }
  invoker.merged = true;
  def[hookKey] = invoker;
}

function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs = data.attrs, props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"".concat(keyInLowerCase, "\" is passed to component ") +
            "".concat(formatComponentName(
              // @ts-expect-error tag is string
              tag || Ctor), ", but the declared prop name is") +
            " \"".concat(key, "\". ") +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"".concat(altKey, "\" instead of \"").concat(key, "\"."));
        }
      }
      checkProp(res, props, key, altKey, true) ||
        checkProp(res, attrs, key, altKey, false);
    }
  }
  return res;
}
function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    }
    else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}